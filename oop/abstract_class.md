# Абстрактный класс

## Введение

Как мы уже обсуждали во [введении в ООП](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию, какие данные хранит этот класс.

Например, класс `Person`:

```java
class Person {
    private int age;
    private String name;

    // some code
}
```

Наш класс содержит переменные, которые хранят возраст и имя персонажа.
У каждого объекта будет свой возраст и имя, в данном случае - это и есть состояние объекта.

Поведение же - это то, что мы можем ожидать при работе с классом, как с ним взаимодействовать и т.д..

За поведение в `Java` отвечает понятие [интерфейса](./interface.md).

До этого мы имели дело с полностью определенными, законченными(завершенными), классами.

Что значит полностью определенный класс или что класс законченный(завершенный)?

Назовем класс полностью определенным, если его поведение(интерфейс) реализовано, т.е мы точно знаем **что** умеет делать объект класса и **как** он это делает, такой класс **полностью** реализует свой интерфейс.
И, что самое главное, такой класс **конкретен**.

Однако, бывают ситуации, когда мы можем описать класс, но определение его поведения **не завершено**. Мы знаем **что** умеет делать класс, но еще не определили **как именно** он это делает.

Возьмем любимый пример всех учебников по программированию для начинающих: класс `Figure` - фигура.

Фигура - это нечто асбтрактное, когда говорят фигура мы не можем представить ничего конкретного.
Фигурой может быть и квадрат, и круг, и прямоугольник.

Каждая фигура состоит из линий, углов, имеет цвет.
Также у фигуры может быть метод `draw` - рисующий фигуру.

Мы описали метод `draw` у фигуры, дали имя, определили аргументы, возвращаемый тип, но не реализовали тело метода, так как каждую фигуру рисуют по-своему, т.е реализация каждой фигуры разная и она определена непосредственно у потомков этого класса.

Точно то же самое можно сказать и про любимца последних заметок по `ООП` - класс `Person`.

При этом каждый `Person` имеет состояние: имя, возраст, рост и т.д.
И также `Person` имеет еще и поведение: ходить, спать и т.д.

Однако он не имеет главного - он не конкретен, при этом он обладает и `поведением`, и `состоянием`.

Для подобных случаев в `Java` можно объявить `абстрактный класс`.

## Объявление

Для того, чтобы объявить класс абстрактным существует ключевое слово `abstract`.

```java
public abstract class Person {
    protected int age;
    protected String name;

    // some code
}
```

Как было сказано выше: абстрактность относится еще и к тому, что `поведение` класса определено не до конца.

Из этого можно сделать вывод, что методы класса, поведение которых мы в данном классе определить/реализовать не можем тоже помечаются как абстрактные:

```java
public abstract class Person {
    protected int age;
    protected String name;

    abstract void greeting();

    // some code
}
```

Если класс содержит **хотя бы один** абстрактный метод - он обязан быть абстрактным классом.

---

**Вопрос**:

Может ли класс быть абстрактным, при этом **не имея** абстрактных методов? Другими словами: валиден ли следующий код?

```java
public abstract class Person {
    protected int age;
    protected String name;

    public void greeting() {
        System.out.println("Привет!");
    }
}
```

**Ответ**:

Абсолютно валиден.

Да, класс может быть абстрактным, при этом не имея абстрактных методов.

Такие классы могут понадобиться вам, чтобы выстраивать более гибкую цепочку иерархий классов. К тому же, никто не запрещает вам при необходимости переопределить какие-то методы такого класса.

---

Как объявить абстрактный класс разобрались, теперь посмотрим как c этим работать.

## Использование

Основным отличием абстрактных классов от обычных в использовании является то, что запрещается создавать экземпляр(instance) абстрактного класса.
Другими словами, вы не можете написать пример ниже с абстрактным классом `Person`:

```java
public abstract class Person {
    protected int age;
    protected String name;

    // some code
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person(); // Compile Error
    }
}
```

Запрет этот наложен именно из-за незавершенности класса.
Экземпляр класса должен олицетворять нечто законченное, то, с чем можно работать и от чего понятно что ждать.

Если задуматься, то в реальном мире происходит нечто похожее - мы оперируем только завершенными объектами, но можем ссылаться на какие-то абстрактные вещи.

Например, вы можете сказать: "Я купил лампу", но без деталей вашей новой покупки каждый человек представит себе "свою" лампу, ведь вы описали нечто абстрактное.

Еще одной аналогией можно привести пример шаблона чертежа дома, на котором обозначены только несущие стены.
Это ещё только эскиз, строить дом по нему нельзя, но на его основе уже можно делать разные варианты законченных чертежей, которые уже можно использовать в строительстве разных домов.

При этом абстрактный класс **может** иметь конструктор.

```java
public abstract class Person {
    private int age;
    private String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

---

**Вопрос**:

А какой смысл в конструкторе, если создать экземпляр абстрактного класса все равно нельзя?

**Ответ**:

Надо помнить, что конструктор супер-класса(родительского) явно участвует в создании объекта класса-наследника, конструктор абстрактного класса - не исключение.
Например, его можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе.

---

**Вопрос**:

Может ли абстрактный класс иметь абстрактный конструктор?

**Ответ**:

Нет, не может.
Ответ на этот вопрос логичен, если задуматься какую роль выполняет конструктор.

---

**Вопрос**:

Может ли абстрактный класс иметь абстрактный статический метод?

**Ответ**:

Снова нет, что, на мой взгляд, довольно логично.
При этом абстрактный класс спокойно может иметь определенный статический метод, хоть это и не совсем желательно.

> Потому что статика плохо ложится на `ООП`.

Более того, абстрактный класс может даже содержать метод `main` - так как это просто еще один статический метод, и абстрактный класс можно выполнять при помощи метода `main`, если не создавать его экземпляров.

---

**Вопрос**:

Может ли абстрактный класс быть объявлен с модификатором `final`? Т.е быть финальным?

**Ответ**:

Разумеется нет, иначе теряется весь смысл абстрактного класса, о чем вам сообщит компилятор, выдав ошибку компиляции.

---

### Когда применять

Когда стоит применять абстрактные классы?

Как вы наверняка поняли, абстрактные классы в основном предназначены для использования в [наследовании](./inheritance.md). Т.е стоит создавать абстрактный класс тогда, когда вам нужен еще один слой абстракции, при этом, на этом слое вы **уже** знаете как определить какие-то параметры или методы.

Возвращаясь к примеру с нашим `Person`-ом:

```java
public abstract class Person {
    protected int age;
    protected String name;

    abstract void greeting();
}

public class Student extends Person {
    @Override
    void greeting() {
        System.out.println("Hello, I'm Student");
    }
}

public class Worker extends Person {
    @Override
    void greeting() {
        System.out.println("Hello, I'm Worker");
    }
}
```

И у `Student`, и у `Worker` **уже** известны общие свойства - возраст и имя, но каждый приветствует собеседника по-своему. То, **как** каждый приветствует собеседника - это уже детали реализации, детали конкретного класса.

В качестве примера использования абстрактных классов в стандартной библиотеке `Java` можно посмотреть любую реализацию `java.util.List`.

Для примера мы возьмем `java.util.ArrayList` и `java.util.LinkedList`. Эти классы являются наследниками `java.util.AbstractList`.

В промежуточном слое, в `java.util.AbstractList`, мы **уже** знаем как определить некоторые метода, например, `indexOf`, но при этом вы еще не знаете как делать `get(int index)`, так как реализация `get` явно зависит от конкретной реализации.

### Анонимные классы

 К слову говоря, необязательно каждый раз для использования абстрактного класса создавать отдельный файл и наследоваться от абстрактного класса, определяя все его абстрактные методы.

 Можно создать `анонимный класс` и определить абстрактные методы.

 ```java
 public abstract class Person {
    protected int age;
    protected String name;

    abstract void greeting();
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person() {
            public void greeting() {
                System.out.println("Привет!");
            }
        }
    }
}
 ```

Здесь объявлен абстрактный класс `Person` и в методе `main` мы создали анонимный класс, реализующий абстрактные методы `Person`.

Таким образом мы **завершили** абстрактный класс, но не дали имени этому завершенному классу, отсюда и название - `анонимный` класс.

### Практика

Для практики можно написать следующую задачу:

Напишите простейшую реализацию игры в покер.

Объявите класс `Карта`(должен ли он быть абстрактным?), этот класс имеет масть и вес, например, шестерка пик или десятка червей.

Объявите класс, который будет отвечать за выигрышные комбинации карт.
Например, пара одной масти, тройка, пять карт в ряд и т.д.

Колода - это массив(список?) из N разных карт.
Колоду можно перемешивать.

Игрок получает в начале 5 карт, случайным образом.

После первого хода каждый игрок может сбросить от 0 до 5 карт и взамен сброшенных взять из колоды новые карты.

После чего каждый по очереди выкладывает карты на стол, а класс-крупье определяет победителя с лучшей комбинацией.

## Заключение

Давайте подведем небольшой промежуточный итог.

Абстрактные классы помогают нам описывать промежуточные состояния, выстраивать иерархии классов и добавлять новые слои абстракции.

> Стоит отметить, что `java.lang.Object` не является абстрактным классом, хоть иногда и кажется, что сделать это было бы логично.
>
> Почему так сделано, я рассуждаю [здесь](../object/intro.md).

Как и полностью завершенные классы, абстрактные классы могут реализовывать интерфейсы.
При этом, так как абстрактный класс может содержать неопределенные методы, допускается реализовывать **не все** методы у реализуемых интерфейсов.

Класс может не содержать абстрактных методов и при этом быть абстрактным.
Однако класс, содержащий хотя бы один абстрактный метод **обязан** быть абстрактным классом.

Абстрактные классы тесно связаны с понятием [интерфейса](./interface.md), поэтому [здесь](./abstract_vs_interface.md) мы разберем отличия абстрактного класса от интерфейса, а также когда что предпочтительнее использовать.

Также стоит познакомиться с [SOLID](./SOLID.md)