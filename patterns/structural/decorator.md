# Паттерн Decorator

## Введение

Представим такую ситуацию, что нужно разработать библиотеку оповещений, которую можно подключить к сервису и получать информацию о событиях.

Изначально основной класс библиотеки `Notifier` отправляет оповещение на устройство клиента. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять сообщение. Но может случиться так, что одной отправки на устройство будет мало и мы захотим отправить сообщение по e-mail или в социальной сети.

Для решения этой проблемы, первое, что приходит в голову - это наследование. Для каждого способа отправки унаследовать основной класс и добавить собственную реализацию. Но ведь в некоторых ситуациях существует необходимость получать информацию по всем каналам связи. Разумеется, всевозможные комбинации подклассов не подойдут, так как такой подход чрезвычайно раздувает код программы.

То есть имеем следующие проблемы:

* Наследование статично. Нет возможности изменить поведение объекта, кроме как создать новый объект, выбрав другой подкласс.
* Невозможно наследовать поведение нескольких классов одновременно, кроме как создать множество подклассов-комбинаций совмещающих поведение.

Для того, чтобы их обойти, заменим наследование *композицией*.

## Принцип построения

*Композиция* заключается в том, что объект содержит ссылку на другой объект и делегирует ему работу, вместо того, чтобы самому наследовать поведение.

Альтернативное название декоратора - обертка. Так как мы помещаем объект в другой объект-обертку, который запускает поведение базового объекта и примешивает к его результату свое.

Главное правило - объекты должны иметь общий интерфейс. Для примера приведенного выше - это будет отправка сообщения.

Аналогией из жизни служит одежда. Надевая что-то мы не изменяет базовый класс и не создаем дочерних. Так, закутавшись в свитер станет теплее. А надев сверху плащ - защитимся от дождя. При это сам человек никак не изменяется.

## Структура

Структура паттерна Декоратор довольно проста:

* `Компонент` задает поведение для оберток
* `Декоратор` преставляет собой обертку, которая это поведение дополняет
* `Клиент` соединяет компонент и декораторы между собой

## Реализация

В качестве примера рассмотрим запись в файл с помощью стандартной библиотеки `java.io`:

Первое, что необходимо сделать: открыть выходной поток. Затем, в зависимости от поставленной задачи *обернуть* открытый поток.

Допустим: 

```java
// Откроем fileWriter для файла
FileWriter fw = new FileWriter(filename);
// Писать побитово слишком долго - буферизуем
BufferedWriter bw = new BufferedWriter(fw);
// Пишем
bw.write("Some string");
bw.close;
fw.close;
```

Разберемся, что происходит внутри:

Первым делом, открываем поток записи в файл

```java
   public class FileWriter extends OutputStreamWriter {
      //some code
      
      public FileWriter(String fileName) throws IOException {
         super(new FileOutputStream(fileName));
      }
   }
```

Класс `FileWriter` наследуется от `OutputStreamWriter`, но не переопределяет метода записи, а лишь создает поток направленный на запись в файл.

Самом же `OutputStreamWriter`:

```java
   public class OutputStreamWriter extends Writer {
      // some code
   
      private final StreamEncoder se;
      
      /**
      * Writes a single character.
      */
      public void write(int c) throws IOException {
         se.write(c);
      }
```

Является оберткой над классом `StreamEncode`, который осуществляет запись. Но, как сказано в комментариях к методу: запись осуществляется по одному символу. Для того, чтобы увеличить скорость записи, буферизируем наш поток, обернув его в `BufferedWriter`.

```java
   public class BufferedWriter extends Writer {
   //some code

   private Writer out;
   
   public void write(String str) throws IOException {
       write(str, 0, str.length());
   }
```

`BufferedWriter` буферизирует полученную строку, используя внутренние методы, и отправляет ее на запись файл.

Таким образом паттерн Декоратор применяется при работе с файлами и другими внешними устройствами.

## Заключение

Паттерн Декоратор следует использовать, когда: 

* Есть необходимость дополнять поведение объектов, незаметно для кода, который их использует.
* Невозможно расширить обязанности объекта с помощью наследования (стоит ключевое слово final).

### Из преимуществ стоит отметить:

* Изменение поведения, без наследования
* Добавление нескольких обязанностей сразу
* Наличие нескольких мелких объектов вместо одного на все случаи жизни

### Недостатки:

* Трудность конфигурации многократно обернутых объектов
* Обилие крошечных классов
