# Структуры данных в Java

## Введение

Понимание структр данных, предоставляемых языком программирования, является основополагающим элементом программирования.
Без осознания того, как хранить и манипулировать данными, а также насколько быстро эти манипуляции происходят невозможно представить себе программирование.

Являясь `объектно-ориентированным` языком программирования, `Java` предоставляет обширный список структур данных, связанных в четкую иерархию с помощью `интерфейсов` и `классов`.

Иерархия существующих структур данных в `Java` выглядит следующим образом:

<img src="../images/collections/collections.png">

> Изображение лучше скачать, markdown почему-то очень сильно его 'сжимает'.
>
> `Зеленым` выделены абстрактные классы.
>
> `Синим` выделены интерфейсы.
>
> `Красным` выделены конкретные реализации.

Корнем в этой иерархии является интерфейс `java.lang.Iterable`.

Интерфейс параметризуется.

Объявление интерфейса выглядит следующим образом:

```java
public interface Iterable<T> {
    // ...
}
```

Суть интерфейса должна быть понятна из названия - он добавляет структуре данных возможность итерирования по структуре данных.

Помимо этого этот интерфейс предоставляет возможность использования `for-each` цикла.

Об этом интерфейсе поговорим подробнее чуть дальше.

Следующим важным интерфейсом является `java.util.Collection`.

Также, как и `java.lang.Iterable`, интерфейс `java.util.Collection` параметризуется.

Объявление:

```java
public interface Collection<E> extends Iterable<E> {
    // ...
}
```

В `Java` все структуры данных, кроме хэш-таблиц(Map), реализуют этот интерфейс, поэтому далее можно называть их `коллекциями`.

Интерфейс `java.util.Collection` предоставляет основные методы для работы с коллекциями.

Выделяется три основынх вида коллекций: List(Список), Queue(Очередь) и Set(Множество).

При этом хэш-таблицы или `Map` стоят несколько обособленно и не реализуют интерфейс `java.util.Collection`.

---

**Вопрос**:

Почему хэш-таблицы не реализуют `java.util.Collection`? 

С чем связана эта обособленность?

**Ответ**:

Эта обособленность скорее всего связана с логическим разделением.

Когда мы говорим про коллекции, то имеется в виду одно множество объектов.

В то время как хэш-таблицы - это два множества объектов, множество ключей
и множество значений, где каждому ключу соответствует свое значение.

Еще одним аргументом может служить то, что при включении хэш-таблиц в иерархию коллекций необходимо будет реализовать итерируемость, но итерироваться по хэш-таблицы можно как по ключам, так и по значениям, что вызывает дополнительную неопределенность.

Скорее всего именно поэтому произошла такая обособленность.

Хотя эти доводы кому-то могут показаться натянутыми, так как в некоторых языках, например, `Scala` хэш-таблицы итерируемы.

---

Уже сказано достаточно про `java.lang.Iterable` и пришла пора поговорить о нем подробнее.

## java.lang.Iterable

Как уже было сказано выше, `java.lang.Iterable` предоставляет нам итератор для обхода коллекции.

Благодаря этому коллекции можно использовать в `for-each` цикле.
Приведенный пример будет на `java.lang.List`, но это не принципиально.

```java
public void printLines(List<String> lines) {
    for(String line : lines) {
        System.out.println(line);
    }
}
```

Основным методом интерфейса `java.lang.Iterable` является:

```java
Iterator<T> iterator();
``` 

// todo
Что такое итератор можно прочитать здесь.


## java.util.Collection

Как уже было сказано выше, `java.util.Collection` предоставляет основные методы работы с коллекциями в `Java`.

Взглянем на основные методы, которые есть у каждой коллекции:

* `boolean add(element)`
* `boolean remove(element)`
* `int size()`
* `boolean isEmpty()`
* `boolean contains(element)`
* `void clear()`

Как можно видеть, все главные операции с любой структурой данных присутствуют.

Разумеется, присутствуют методы, для добавления к коллекции не только одного элемента, а целого множества элементов, также как и удаления, также существует возможность удалять по некоторому предикату, но автор данного текста для краткости опустил их перечисление.

> Предикат - это некоторое условие.

Здесь все довольно обычно, кроме, возможно, `boolean add(element)`.

Дело в том, что при добавлении элемента в коллекцию метод вернет `true`, если коллекция была изменена в результате добавления. Если же текущая реализация коллекции не может содержать дубликаты и уже содержит добавляемый элемент будет возвращено значение `false`.

Еще одним интересным моментом является то, что интерфейс `java.util.Collection` **не предоставляет** метода, который достает элемент из коллекции.

Т.е интерфейс `java.util.Collection` предоставляет возможность только добавлять и удалять значения из коллекции, но не извлекать.

---

**Вопрос**:

Почему же  `java.util.Collection` не предоставляет методов для извлечения элемента из коллекции? 

**Ответ**:

Извлечение элемента является довольно специфичным поведением для каждой реализации.
Например, не все реализации `java.util.Set` упорядочены, отсюда извлечение элемента по индексу является невыполнимым.

Так как множество исключает содержание дубликатов, то возможность извлечения по элементу также выглядит спорным моментом.

Если существует некоторое множество, то вместо `get(element)` достаточно вызвать `contains(element)`.

Так как если элемент есть в множестве, то значение будет `true`, а это значит что `element`, по которому делали `contains`, будет точно тем же, если бы был вызван `get(element)`.

Стоит отметить, что методы извлечения элемента из коллекции добавляются в интерфейсах `java.util.List` и `java.util.Queue`.

---

Наследниками поведения `java.util.Collection` являются:

* [java.util.List](./list/intro.md)
* [java.util.Set](./set/intro.md)
* [java.util.Queue](./queue/intro.md)

Подробнее о [java.util.Map](./map/intro.md).
